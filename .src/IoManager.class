' Gambas class file

'Fast

Export

Public IoPort As SerialPort[] = New SerialPort[]                           'Can support n ports And controllers
 
Public WaitingForReply As Integer = 0
Public RxDataBusy As Integer = 0

Private SendQueue As QueueEntry[] = New QueueEntry[]  ' max starting queue length ?

Private RxQueue As ReadQueues = New ReadQueues         ' Recieved messages for dispatch

Public IoTimer As Timer = New Timer As "MyTimer"
Public DispatchTimer As Timer = New Timer As "MyDispatch"

Public IoTimeOutDelay As Integer = 100 ' can be changed by the user default to 100

Public IoTimeLastTx As Float 
Public IoTimeLastRx As Float

Public IoTrace As Boolean = False
Public IoPortCount As Integer = 0
Public Const Broadcast As Integer = -1

Event Read(Id As Integer, len As Integer, Buffer As Byte[], RxTime As Float, TxTime As Float)


Public Sub IoTraceSet(OnOff As Boolean)
  
  IoTrace = OnOff
  RxQueue.IoTrace = OnOff
  
End

Public Sub closeall()
  
  IoPort[0].Close()
  IoTimer.Stop()
  DispatchTimer.enabled = False
  
End


Public Sub _new(PortName As String[])

  Dim MyIoPort As SerialPort
  

  MyIoPort = New SerialPort As ("IoPort" & Str(IoPortCount))
  MyIoPort.PortName = PortName
  
  MyIoPort.Speed = 115200
  MyIoPort.FlowControl = SerialPort.None

  If IoTrace Then Print Now, MyIoPort.DataBits, MyIoPort.Even, MyIoPort.Parity, MyIoPort.Speed, MyIoPort.FlowControl, MyIoPort.Blocking, MyIoPort.StopBits
  If IoTrace Then Print Now, "Watch Object =", ("IoPort" & Str(IoPortCount))
  
  MyIoPort.Open()
  MyIoPort.DTR = True
  
  RxQueue.ReadPort(MyIoPort)
  RxQueue.IoTrace = IoTrace
  
  IoPort.Add(MyIoPort)
  Inc IoPortCount
  
  DispatchTimer.Delay = 1
  
Catch 
    Message("Open of the IO Port failed Port#=" & IoPortCount & ", Error=" & Error.text & "(" & Error.Where & ")")
    Quit 0
End


Public Sub IoPort0_Read()

 Dim Ilen, Rpos As Integer
 Dim ReadQueue As Byte[]
 
  While RxDataBusy
    If IoTrace Then Print Now, "Receive in busy wait state"
    Wait 0.001
  Wend
  
  Inc RxDataBusy
    
    ReadQueue = RxQueue[Last]
    
    IoTimer.Enabled = False ' we have an input message so stop the time if it is running
    If WaitingForReply Then Dec WaitingForReply
        Logger("<~RX Msg Recieved to Buffer Offset=" & Rpos & ", Length=" & Ilen, "<~Rx Buf Before Read", ReadQueue)
    Ilen = Lof(Last)
    Rpos = ReadQueue.length

    ReadQueue.Resize(RPos + Ilen)
    
    Try ReadQueue.Read(Last, Rpos, Ilen)
    
    IoTimeLastRx = Timer
    
    Logger("IoPort=" & Str(Last), "<~Rx Read Len=" & iLen & " : ", ReadQueue)
    
    DispatchTimer.Enabled = True
    
  Dec RxDataBusy
  
    Catch 
        Print Now, "IoPort_Read Failed ", Error.text, Error.where, Error.code, "\n"
        Dec RxDataBusy
  End
  
Public Sub IoPort1_Read()
 IoPort0_Read()
End
Public Sub IoPort2_Read()
 IoPort0_Read()
End
Public Sub IoPort3_Read()
 IoPort0_Read()
End
Public Sub IoPort4_Read()
 IoPort0_Read()
End

  
 Public Sub MyDispatch_Timer()
 
   Dim IoPartBuf As Byte[]
   
    DispatchTimer.enabled = False
    For Each IoPartBuf In RxQueue
      IoTimeLastRx = Timer
      Logger("++Rx> Dispatch event to ServoManager for processing", "<~~Rx : ", IoPartBuf)
      Raise read(IoPartBuf[Servo.IdOffset], IoPartBuf[Servo.LenOffset], IoPartBuf, Timer, IoTimeLastTx)
    Next
      
      ' IoPartBuf = GetMessagefromQ()
      ' 
      ' While Not IsNull(IoPartBuf)
      '  
      '   IoTimeLastRx = Timer
      '   
      '   Logger("++Rx> Dispatch event to ServoManager for processing", "<~~Rx : ", IoPartBuf)
      '   
      '   Raise read(IoPartBuf[Servo.IdOffset], IoPartBuf[Servo.LenOffset], IoPartBuf, Timer, IoTimeLastTx)
      '   
      '   IoPartBuf = GetMessagefromQ()
      '   
      ' Wend
      
      If Not WaitingForReply Then SendFromQ()
      
End

' Private Sub GetMessagefromQ() As Byte[]
'   Dim IoBuf
'   
'   For Each IoBuf In RxQueue
'     Logger("", "<-IoMgr From Queue:", IoBuf)
'     Return IoBuf
'   Next
'   
'   If IoTrace Then Print Now, "<-IoMgr no more Buffer in Q"
'   
'   Return Null
'   
'   Catch
'     Print "GetMessagefromQ crash " & Error.text, Error.where, Error.Code, "\n"
'     Print "to"
' End



Public Sub SendCommand(IoPortIndex As Integer, TheCmd As Byte[], Optional Waiting As Boolean = False, TimeOut As Integer = 1000)
Dim Qh As QueueEntry
Dim QBuffer As Byte[]

  If IoTrace Then Print Now, "~Tx Wait=" & Str(Waiting) & ", Timeout=" & Timeout & ", CurrentWait=" & Str(WaitingForReply), "Q Len =" & SendQueue.length
  
  If SendQueue.length > 40 Then
      IoTimer.Delay = 3
      IoTimer.enabled = True
      Print Now, " Emergency Timer Started Queue length > 40 items\n" 
  Endif
    QBuffer = TheCmd.Copy()
    Qh = New QueueEntry(IoPortIndex, Waiting, QBuffer, TimeOut)
    SendQueue.Add(Qh, 0)
    SendFromQ() 
    
End


Private Sub SendFromQ()
  Dim Qh As QueueEntry
  Dim IoIf As SerialPort
  
  While (waitingforreply = 0) 
    If (SendQueue.length > 0)
    
      qh = SendQueue.pop()
      
      If qh.Waiting Then Inc WaitingForReply
      
      chksum(qh.Buffer)
      Logger("~Tx-DQ>Next Buffer from Queue " & "Q Len = " & SendQueue.length & " IoPort=" & Str(qh.IoPort), "~Tx-DQ>", qh.buffer)
      
      If qh.IoPort = -1 Then 
        
       For Each IoIf In IoPort
         writedata(IoIf, qh.data)
       Next
        
      Else
        
        IoIf = IoPort[qh.IoPort]
        writedata(IoIf, qh.buffer)
        
      Endif
      
      IoTimeLastTx = Timer
      
      If WaitingForReply Then
        IoTimer.Enabled = False
        IoTimer.Delay = qh.TimeOut
        IoTimer.Enabled = True
      Endif
      
    Else
      If IoTrace Then Print Now, "-Tx Send Queue is empty break out of loop\n"
      Break
    Endif
    
  Wend
  
End

Public Sub writedata(IoPortOut As SerialPort, data As Byte[]) 

        IoPortOut.Begin()
        Write #IoPortOut, data As Byte[]
        IoPortOut.Send
        
End


Public Sub MyTimer_Timer()

  If IoTrace Then Print Now, "~> Send Timeout happened!\n"
  
  IoPort0_Read() ' just check for more data
  
  IoTimer.Enabled = False
  
  If WaitingForReply Then
    Dec WaitingForReply
    SendFromQ()
  Endif
  
End


'Checksum: The calculation method Is As follows:
'Checksum = ~(ID+ Length+Cmd+ Prm1+...PrmN)If the numbers in the
'brackets are calculated And exceeded 255, Then take the lowest one byte, "~"
'means Negation.

Public Sub chksum(cmdBuff As Byte[])
Dim cmdlen As Integer = (cmdBuff[3] - 1)
Dim chksumcalc As Integer = cmdBuff[2]

  For i As Integer = 0 To cmdlen - 1 
    chksumcalc += cmdBuff[3 + i]
  Next
  
  chksumcalc = (Not chksumcalc) And &HFF
  cmdBuff[cmdBuff[3] + 2] = chksumcalc
  
End
Public Sub Logger(msghdr As String, BufferHdr As String, buffer As Byte[], Optional ID As Integer = -1)
  Dim inByte As Byte
  Dim inData As String
  
  If IoTrace Then 
        If Not (msghdr = "") Then Print Now, Subst(Msghdr, id) & "\n"
        inData = Now & "-" & BufferHdr
        For Each inByte In buffer
         inData &= (Str$(inByte) & " ")
         Next
        Print inData & "\n"
    Endif
  
End
